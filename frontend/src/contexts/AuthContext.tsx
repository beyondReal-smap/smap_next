'use client';

import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';
import { AuthState, AuthAction, UserProfile, GroupWithMembers, LoginRequest } from '@/types/auth';
import authService from '@/services/authService';
import { getSession } from 'next-auth/react';
import { useDataCache } from '@/contexts/DataCacheContext';
import dataPreloadService from '@/services/dataPreloadService';

// Ï¥àÍ∏∞ ÏÉÅÌÉú
const initialState: AuthState = {
  isLoggedIn: false,
  user: null,
  selectedGroup: null,
  loading: true,
  error: null,
};

// Reducer Ìï®Ïàò
const authReducer = (state: AuthState, action: AuthAction): AuthState => {
  switch (action.type) {
    case 'LOGIN_START':
      return {
        ...state,
        loading: true,
        error: null,
      };

    case 'LOGIN_SUCCESS':
      return {
        ...state,
        isLoggedIn: true,
        user: action.payload,
        loading: false,
        error: null,
      };

    case 'LOGIN_FAILURE':
      return {
        ...state,
        isLoggedIn: false,
        user: null,
        loading: false,
        error: action.payload,
      };

    case 'LOGOUT':
      return {
        ...initialState,
        loading: false,
      };

    case 'UPDATE_USER':
      return {
        ...state,
        user: state.user ? { ...state.user, ...action.payload } : null,
      };

    case 'SELECT_GROUP':
      return {
        ...state,
        selectedGroup: action.payload,
      };

    case 'UPDATE_GROUPS':
      return {
        ...state,
        user: state.user ? {
          ...state.user,
          groups: action.payload,
          ownedGroups: action.payload.filter(group => group.myRole.isOwner),
          joinedGroups: action.payload.filter(group => !group.myRole.isOwner),
        } : null,
      };

    case 'SET_LOADING':
      return {
        ...state,
        loading: action.payload,
      };

    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
      };

    default:
      return state;
  }
};

// Context ÏÉùÏÑ±
interface AuthContextType extends AuthState {
  login: (credentials: LoginRequest) => Promise<void>;
  logout: () => Promise<void>;
  updateUser: (updateData: Partial<UserProfile>) => Promise<void>;
  selectGroup: (group: GroupWithMembers | null) => void;
  refreshUserData: () => Promise<void>;
  refreshGroups: () => Promise<void>;
  setError: (error: string | null) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Provider Ïª¥Ìè¨ÎÑåÌä∏
interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, initialState);
  
  // DataCache ÏÇ¨Ïö©
  const {
    setUserProfile,
    setUserGroups,
    setGroupMembers,
    setScheduleData,
    setLocationData,
    setGroupPlaces,
    setDailyLocationCounts,
    clearAllCache
  } = useDataCache();

  // Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ïãú Îç∞Ïù¥ÌÑ∞ ÌîÑÎ¶¨Î°úÎî©
  const executeDataPreloading = async (userId: number) => {
    try {
      console.log('[AUTH] üöÄ Îç∞Ïù¥ÌÑ∞ ÌîÑÎ¶¨Î°úÎî© ÏãúÏûë:', userId);
      
      const preloadResult = await dataPreloadService.preloadAllData({
        userId,
        onProgress: (step: string, progress: number) => {
          console.log(`[AUTH] ÌîÑÎ¶¨Î°úÎî© ÏßÑÌñâ: ${step} (${progress}%)`);
        },
        onError: (error: Error, step: string) => {
          console.error(`[AUTH] ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®: ${step}`, error);
        }
      });

      // ÌîÑÎ¶¨Î°úÎî©Îêú Îç∞Ïù¥ÌÑ∞Î•º Ï∫êÏãúÏóê Ï†ÄÏû•
      if (preloadResult.userProfile) {
        setUserProfile(preloadResult.userProfile);
        console.log('[AUTH] ‚úÖ ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å');
      }

      if (preloadResult.userGroups.length > 0) {
        setUserGroups(preloadResult.userGroups);
        console.log('[AUTH] ‚úÖ ÏÇ¨Ïö©Ïûê Í∑∏Î£π Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å:', preloadResult.userGroups.length);
      }

      // Í∞Å Í∑∏Î£πÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï∫êÏãú Ï†ÄÏû•
      Object.keys(preloadResult.groupMembers).forEach(groupId => {
        const members = preloadResult.groupMembers[groupId];
        if (members) {
          setGroupMembers(parseInt(groupId), members);
          console.log(`[AUTH] ‚úÖ Í∑∏Î£π ${groupId} Î©§Î≤Ñ Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å:`, members.length);
        }
      });

      Object.keys(preloadResult.monthlySchedules).forEach(groupId => {
        const schedules = preloadResult.monthlySchedules[groupId];
        if (schedules) {
          const today = new Date().toISOString().split('T')[0];
          setScheduleData(parseInt(groupId), today, schedules);
          console.log(`[AUTH] ‚úÖ Í∑∏Î£π ${groupId} Ïä§ÏºÄÏ§Ñ Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å`);
        }
      });

      Object.keys(preloadResult.groupPlaces).forEach(groupId => {
        const places = preloadResult.groupPlaces[groupId];
        if (places) {
          setGroupPlaces(parseInt(groupId), places);
          console.log(`[AUTH] ‚úÖ Í∑∏Î£π ${groupId} Ïû•ÏÜå Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å:`, places.length);
        }
      });

      Object.keys(preloadResult.todayLocationData).forEach(groupId => {
        const locationData = preloadResult.todayLocationData[groupId];
        if (locationData) {
          const today = new Date().toISOString().split('T')[0];
          setLocationData(parseInt(groupId), today, locationData);
          console.log(`[AUTH] ‚úÖ Í∑∏Î£π ${groupId} Ïò§Îäò ÏúÑÏπò Îç∞Ïù¥ÌÑ∞ Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å`);
        }
      });

      Object.keys(preloadResult.dailyLocationCounts).forEach(groupId => {
        const counts = preloadResult.dailyLocationCounts[groupId];
        if (counts) {
          setDailyLocationCounts(parseInt(groupId), counts);
          console.log(`[AUTH] ‚úÖ Í∑∏Î£π ${groupId} ÏùºÎ≥Ñ Ïπ¥Ïö¥Ìä∏ Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å`);
        }
      });

      console.log('[AUTH] üéâ Î™®Îì† Îç∞Ïù¥ÌÑ∞ ÌîÑÎ¶¨Î°úÎî© Î∞è Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å!');
      
    } catch (error) {
      console.error('[AUTH] ‚ùå Îç∞Ïù¥ÌÑ∞ ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®:', error);
      // ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®Ìï¥ÎèÑ Î°úÍ∑∏Ïù∏ÏùÄ Í≥ÑÏÜç ÏßÑÌñâ
    }
  };

  // Ï¥àÍ∏∞ Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏
  useEffect(() => {
    const initializeAuth = async () => {
      try {
        console.log('[AUTH CONTEXT] Ï¥àÍ∏∞ Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏ ÏãúÏûë');
        
        // 1. NextAuth ÏÑ∏ÏÖò Î®ºÏ†Ä ÌôïÏù∏ (ÏµúÏã† ÏÉÅÌÉú)
        console.log('[AUTH CONTEXT] NextAuth ÏÑ∏ÏÖò ÌôïÏù∏');
        const session = await getSession();
        
        if (session?.backendData?.member) {
          console.log('[AUTH CONTEXT] NextAuth ÏÑ∏ÏÖòÏóêÏÑú ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Î∞úÍ≤¨:', session.backendData.member.mt_name, 'ID:', session.backendData.member.mt_idx);
          
          // Í∏∞Ï°¥ authService Îç∞Ïù¥ÌÑ∞ÏôÄ ÎπÑÍµêÌïòÏó¨ Îã§Î•∏ ÏÇ¨Ïö©ÏûêÎ©¥ Ï¥àÍ∏∞Ìôî
          const existingUserData = authService.getUserData();
          if (existingUserData && existingUserData.mt_idx !== session.backendData.member.mt_idx) {
            console.log('[AUTH CONTEXT] Îã§Î•∏ ÏÇ¨Ïö©Ïûê Í∞êÏßÄ, Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî:', existingUserData.mt_idx, '->', session.backendData.member.mt_idx);
            authService.clearAuthData(); // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÏÇ≠Ï†ú
          }
          
          // NextAuth ÏÑ∏ÏÖòÏùò Îç∞Ïù¥ÌÑ∞Î•º authServiceÏóê Ï†ÄÏû•
          const userData = session.backendData.member;
          const token = session.backendData.token || '';
          
          console.log('[AUTH CONTEXT] ÌÜ†ÌÅ∞ Ï†ÄÏû•:', token ? 'ÌÜ†ÌÅ∞ ÏûàÏùå' : 'ÌÜ†ÌÅ∞ ÏóÜÏùå');
          
          authService.setUserData(userData);
          authService.setToken(token);
          
          // localStorageÏóêÎèÑ ÏßÅÏ†ë Ï†ÄÏû• (apiClientÍ∞Ä Ïù∏ÏãùÌï† Ïàò ÏûàÎèÑÎ°ù)
          if (typeof window !== 'undefined' && token) {
            localStorage.setItem('auth-token', token);
            console.log('[AUTH CONTEXT] localStorageÏóê ÌÜ†ÌÅ∞ Ï†ÄÏû• ÏôÑÎ£å');
          }
          
          dispatch({ type: 'LOGIN_SUCCESS', payload: userData });
          // ÏµúÏã† Îç∞Ïù¥ÌÑ∞Î°ú Í∞±Ïã†
          await refreshUserData();
          
          // üöÄ Í∏∞Ï°¥ Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎèÑ ÌîÑÎ¶¨Î°úÎî© Ïã§Ìñâ (Î∞±Í∑∏ÎùºÏö¥Îìú)
          executeDataPreloading(userData.mt_idx).catch(error => {
            console.error('[AUTH] Í∏∞Ï°¥ Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®:', error);
          });
          
          return;
        }

        // 2. NextAuth ÏÑ∏ÏÖòÏù¥ ÏóÜÏúºÎ©¥ authServiceÏóêÏÑú Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÌôïÏù∏
        const isLoggedInFromService = authService.isLoggedIn();
        console.log('[AUTH CONTEXT] authService.isLoggedIn():', isLoggedInFromService);
        
        if (isLoggedInFromService) {
          const userData = authService.getUserData();
          console.log('[AUTH CONTEXT] authService.getUserData():', userData);
          if (userData) {
            console.log('[AUTH CONTEXT] authServiceÏóêÏÑú ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Î∞úÍ≤¨:', userData.mt_name);
            dispatch({ type: 'LOGIN_SUCCESS', payload: userData });
            // ÏµúÏã† Îç∞Ïù¥ÌÑ∞Î°ú Í∞±Ïã†
            await refreshUserData();
            
            // üöÄ authService Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©ÏûêÎèÑ ÌîÑÎ¶¨Î°úÎî© Ïã§Ìñâ (Î∞±Í∑∏ÎùºÏö¥Îìú)
            executeDataPreloading(userData.mt_idx).catch(error => {
              console.error('[AUTH] authService Î°úÍ∑∏Ïù∏ ÏÇ¨Ïö©Ïûê ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®:', error);
            });
            
            return;
          }
        }

        // 3. Îëò Îã§ ÏóÜÏúºÎ©¥ Î°úÍ∑∏Ïù∏ÎêòÏßÄ ÏïäÏùÄ ÏÉÅÌÉú
        console.log('[AUTH CONTEXT] Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÏóÜÏùå');
        dispatch({ type: 'SET_LOADING', payload: false });
        
      } catch (error) {
        console.error('[AUTH CONTEXT] Ï¥àÍ∏∞ Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®:', error);
        dispatch({ type: 'SET_LOADING', payload: false });
      }
    };

    initializeAuth();
  }, []);

    // NextAuth ÏÑ∏ÏÖò Î≥ÄÍ≤Ω Í∞êÏßÄ (ÎπÑÌôúÏÑ±Ìôî - Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ)
  // useEffect(() => {
  //   const checkSessionChange = async () => {
  //     try {
  //       const session = await getSession();
        
  //       if (session?.backendData?.member) {
  //         const sessionUserId = session.backendData.member.mt_idx;
  //         const currentUserId = state.user?.mt_idx;
          
  //         // ÏÑ∏ÏÖòÏùò ÏÇ¨Ïö©ÏûêÏôÄ ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÍ∞Ä Îã§Î•¥Î©¥ ÏóÖÎç∞Ïù¥Ìä∏
  //         if (currentUserId && sessionUserId !== currentUserId) {
  //           console.log('[AUTH CONTEXT] ÏÑ∏ÏÖò ÏÇ¨Ïö©Ïûê Î≥ÄÍ≤Ω Í∞êÏßÄ:', currentUserId, '->', sessionUserId);
            
  //           // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
  //           authService.clearAuthData();
            
  //           // ÏÉàÎ°úÏö¥ ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
  //           const userData = session.backendData.member;
  //           const token = session.backendData.token || '';
            
  //           console.log('[AUTH CONTEXT] ÏÑ∏ÏÖò Î≥ÄÍ≤Ω - ÌÜ†ÌÅ∞ Ï†ÄÏû•:', token ? 'ÌÜ†ÌÅ∞ ÏûàÏùå' : 'ÌÜ†ÌÅ∞ ÏóÜÏùå');
            
  //           authService.setUserData(userData);
  //           authService.setToken(token);
            
  //           // localStorageÏóêÎèÑ ÏßÅÏ†ë Ï†ÄÏû• (apiClientÍ∞Ä Ïù∏ÏãùÌï† Ïàò ÏûàÎèÑÎ°ù)
  //           if (typeof window !== 'undefined' && token) {
  //             localStorage.setItem('auth-token', token);
  //             console.log('[AUTH CONTEXT] ÏÑ∏ÏÖò Î≥ÄÍ≤Ω - localStorageÏóê ÌÜ†ÌÅ∞ Ï†ÄÏû• ÏôÑÎ£å');
  //           }
            
  //           dispatch({ type: 'LOGIN_SUCCESS', payload: userData });
  //           await refreshUserData();
  //         }
  //       }
  //     } catch (error) {
  //       console.error('[AUTH CONTEXT] ÏÑ∏ÏÖò Î≥ÄÍ≤Ω ÌôïÏù∏ Ïã§Ìå®:', error);
  //     }
  //   };

  //   // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÏÑ∏ÏÖò Î≥ÄÍ≤Ω ÌôïÏù∏ (30Ï¥àÎßàÎã§Î°ú Î≥ÄÍ≤Ω)
  //   const interval = setInterval(checkSessionChange, 30000);
    
  //   return () => clearInterval(interval);
  // }, [state.user?.mt_idx]);

  // Î°úÍ∑∏Ïù∏
  const login = async (credentials: LoginRequest): Promise<void> => {
    try {
      dispatch({ type: 'LOGIN_START' });
      const response = await authService.login(credentials);
      
      if (response.success && response.data) {
        // authService.login()ÏóêÏÑú Ïù¥ÎØ∏ getUserProfile()Ïù¥ Ìò∏Ï∂úÎêòÍ≥† ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞Í∞Ä Ï†ÄÏû•Îê®
        // Ï†ÄÏû•Îêú ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏ÏôÄÏÑú ÏÇ¨Ïö©
        const userProfile = authService.getUserData();
        
        if (userProfile) {
          dispatch({ type: 'LOGIN_SUCCESS', payload: userProfile });
          
          // üöÄ Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ïãú Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Îç∞Ïù¥ÌÑ∞ ÌîÑÎ¶¨Î°úÎî© Ïã§Ìñâ
          executeDataPreloading(userProfile.mt_idx).catch(error => {
            console.error('[AUTH] Î°úÍ∑∏Ïù∏ ÌõÑ ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®:', error);
            // ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®Îäî Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µÏóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÏùå
          });
        } else {
          // authServiceÏóêÏÑú ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•Ïù¥ Ïã§Ìå®Ìïú Í≤ΩÏö∞, Îã§Ïãú ÏãúÎèÑ
          console.warn('[AUTH] authServiceÏóêÏÑú ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå, Ïû¨ÏãúÎèÑ');
          const userProfile = await authService.getUserProfile(response.data.member.mt_idx);
          dispatch({ type: 'LOGIN_SUCCESS', payload: userProfile });
          
          // üöÄ Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ïãú Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Îç∞Ïù¥ÌÑ∞ ÌîÑÎ¶¨Î°úÎî© Ïã§Ìñâ
          executeDataPreloading(userProfile.mt_idx).catch(error => {
            console.error('[AUTH] Î°úÍ∑∏Ïù∏ ÌõÑ ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®:', error);
            // ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®Îäî Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µÏóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÏùå
          });
        }
      } else {
        throw new Error(response.message || 'Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      }
    } catch (error: any) {
      const errorMessage = error.message || 'Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.';
      dispatch({ type: 'LOGIN_FAILURE', payload: errorMessage });
      throw error;
    }
  };

  // Î°úÍ∑∏ÏïÑÏõÉ
  const logout = async (): Promise<void> => {
    try {
      await authService.logout();
      
      // üóëÔ∏è Î°úÍ∑∏ÏïÑÏõÉ Ïãú Î™®Îì† Ï∫êÏãú ÏÇ≠Ï†ú
      clearAllCache();
      console.log('[AUTH] Î°úÍ∑∏ÏïÑÏõÉ Ïãú Î™®Îì† Ï∫êÏãú ÏÇ≠Ï†ú ÏôÑÎ£å');
      
      dispatch({ type: 'LOGOUT' });
    } catch (error) {
      console.error('[AUTH CONTEXT] Î°úÍ∑∏ÏïÑÏõÉ Ïã§Ìå®:', error);
      // Î°úÍ∑∏ÏïÑÏõÉÏùÄ ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥ÎèÑ ÏÉÅÌÉúÎ•º Ï¥àÍ∏∞Ìôî
      clearAllCache(); // ÏóêÎü¨ ÏãúÏóêÎèÑ Ï∫êÏãúÎäî ÏÇ≠Ï†ú
      dispatch({ type: 'LOGOUT' });
    }
  };

  // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
  const updateUser = async (updateData: Partial<UserProfile>): Promise<void> => {
    if (!state.user) {
      throw new Error('Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©ÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§.');
    }

    try {
      const updatedUser = await authService.updateUserProfile(state.user.mt_idx, updateData);
      dispatch({ type: 'UPDATE_USER', payload: updatedUser });
    } catch (error: any) {
      const errorMessage = error.message || 'ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.';
      dispatch({ type: 'SET_ERROR', payload: errorMessage });
      throw error;
    }
  };

  // Í∑∏Î£π ÏÑ†ÌÉù
  const selectGroup = (group: GroupWithMembers | null): void => {
    dispatch({ type: 'SELECT_GROUP', payload: group });
  };

  // ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ®
  const refreshUserData = async (): Promise<void> => {
    if (!state.user) return;

    try {
      const userProfile = await authService.getUserProfile(state.user.mt_idx);
      authService.setUserData(userProfile);
      dispatch({ type: 'LOGIN_SUCCESS', payload: userProfile });
    } catch (error: any) {
      console.error('[AUTH CONTEXT] ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®:', error);
      dispatch({ type: 'SET_ERROR', payload: 'ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º ÏÉàÎ°úÍ≥†Ïπ®Ìï† Ïàò ÏóÜÏäµÎãàÎã§.' });
    }
  };

  // Í∑∏Î£π Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ®
  const refreshGroups = async (): Promise<void> => {
    if (!state.user) return;

    try {
      const groups = await authService.getUserGroups(state.user.mt_idx);
      dispatch({ type: 'UPDATE_GROUPS', payload: groups });
    } catch (error: any) {
      console.error('[AUTH CONTEXT] Í∑∏Î£π Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®:', error);
      dispatch({ type: 'SET_ERROR', payload: 'Í∑∏Î£π Ï†ïÎ≥¥Î•º ÏÉàÎ°úÍ≥†Ïπ®Ìï† Ïàò ÏóÜÏäµÎãàÎã§.' });
    }
  };

  // ÏóêÎü¨ ÏÑ§Ï†ï
  const setError = (error: string | null): void => {
    dispatch({ type: 'SET_ERROR', payload: error });
  };

  const contextValue: AuthContextType = {
    ...state,
    login,
    logout,
    updateUser,
    selectGroup,
    refreshUserData,
    refreshGroups,
    setError,
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

// Custom Hook
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuthÎäî AuthProvider ÎÇ¥Î∂ÄÏóêÏÑú ÏÇ¨Ïö©ÎêòÏñ¥Ïïº Ìï©ÎãàÎã§.');
  }
  return context;
};

// Ìé∏ÏùòÎ•º ÏúÑÌïú Í∞úÎ≥Ñ hooks
export const useUser = () => {
  const { user } = useAuth();
  return user;
};

export const useGroups = () => {
  const { user } = useAuth();
  return {
    allGroups: user?.groups || [],
    ownedGroups: user?.ownedGroups || [],
    joinedGroups: user?.joinedGroups || [],
  };
};

export const useSelectedGroup = () => {
  const { selectedGroup, selectGroup } = useAuth();
  return { selectedGroup, selectGroup };
}; 